# -*- coding: utf-8 -*-
"""
Automatically generated by Colaboratory.

# The simple way to implement N-gram Language model
"""

import nltk
nltk.download('brown')
from collections import Counter
import string
import re
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import KFold
from sklearn.model_selection import train_test_split
from nltk.corpus import brown
from random import choices

X=[]
file=brown.sents()
X=clean(file)
X=clean(X)
X=lower(X)
X_train, X_test = train_test_split(X,test_size=0.2, random_state=1)

class data_prep:
  def __init__(self,train_data,test_data,n_gram=int(),threshold=int()):
    self.train=train_data
    self.test=test_data
    self.ng=n_gram
    self.t=threshold

  def n_list(self,data):
    data_list=[]
    for i in data:
      for j in range(self.ng-1):
        data_list.append('<s>')
      for k in i:
        data_list.append(k)
      data_list.append('</s>')
    return(data_list)
  
  def cut_off(self,data_list):
    data_vocab=Counter(data_list)
    count_sum=0
    data_vocab_new={}
    for i in data_vocab:
      if data_vocab[i]<self.t:
        count_sum+=data_vocab[i]
      else:
        data_vocab_new[i]=data_vocab[i]
    data_vocab_new['<UNK>']=count_sum
    return(data_vocab_new)

  def replace_unk(self,data_list,vocab):
    data_list_replace=[]
    for i in data_list:
      if i in vocab:
        data_list_replace.append(i)
      else:
        data_list_replace.append('<UNK>')
    return(data_list_replace)

  def transform(self):
    self.train_list=self.n_list(self.train)
    self.test_list=self.n_list(self.test)
    self.data_vocab=self.cut_off(self.train_list)
    self.train_list_new=self.replace_unk(self.train_list,self.data_vocab)
    self.test_list_new=self.replace_unk(self.test_list,self.data_vocab)
    return(self.train_list_new,self.test_list_new,self.data_vocab)


class prob_transform:
  def __init__(self,data,n_gram=int()):
    self.data=data
    self.ng=n_gram

  def transform(self):
    l=len(self.data)
    if self.ng == 1:
      return(Counter(self.data))
    else:
      data_prob={}
      for i in range(l-self.ng+1):
        temp_key=tuple(self.data[i:i+self.ng-1])
        if temp_key not in data_prob:
          data_prob[temp_key]={}
          data_prob[temp_key][self.data[i+self.ng-1]]=1
        else:
          if self.data[i+self.ng-1] not in data_prob[temp_key]:
            data_prob[temp_key][self.data[i+self.ng-1]]=1
          else:
            data_prob[temp_key][self.data[i+self.ng-1]]+=1
      return(data_prob)


class smoothing:
  def __init__(self,test_data,prob_dict,vocab,n_gram=int()):
    self.data=test_data
    self.prob=prob_dict
    self.vocab=vocab
    self.ng=n_gram

  def calc(self,lamb=float()):
    n=len(self.data)
    m=len(self.vocab)
    entro=0
    if self.ng ==1:
      count_sum=sum(self.prob.values())
      for i in self.data:
        c=self.prob[i]
        prob=(c+lamb)/(count_sum+m*lamb)
        entro+= -np.log2(prob)
    else:
      for i in range(n-self.ng+1):
        if self.data[i+self.ng-2]=='</s>':
          continue
        else:
          end=i+self.ng-1
          temp_key=tuple(self.data[i:end])
          if temp_key not in self.prob:
            entro+=np.log2(m)
          else:
            count_sum=sum(self.prob[temp_key].values())
            if self.data[end] not in self.prob[temp_key]:
              c=0
            else:
              c=self.prob[temp_key][self.data[end]]
            prob=(c+lamb)/(count_sum+m*lamb) 
            entro+=-np.log2(prob)       
    entro=entro/n
    return(entro)

class sents_gene:
  def __init__(self,prob_dict,iteration=int()):
    self.it=iteration
    self.prob=prob_dict

  def uni_gene(self,lamb=float()):
    uni_keys=[]
    uni_values=[]
    for i in self.prob:
      uni_keys.append(i)
      uni_values.append(self.prob[i]+lamb)
    for i in range(self.it):
      I=0
      s=''
      while True:
        word = choices(uni_keys,uni_values)[0]
        if word != '</s>':
          s+=word+' '
          I+=1
        elif word =='</s>' and I ==0:
          continue
        else:
          break
      print(s+' </s>')

  def other_gene(self,n_gram=int(),lamb=float(),vocab_list=list()):
    for i in range(self.it):
      I=0
      s='<s> ' *(n_gram-1)
      key=('<s>',)*(n_gram-1)
      while True:
        if key not in self.prob:
          word=choices(vocab_list)[0]
          if word =='</s>':
            break
          else:
            s+=word+' '
            key=key[1:]+(word,)
        else:
          temp_dict=self.prob[key]
          temp_values=[]
          for i in vocab_list:
            if i not in temp_dict:
              temp_values.append(lamb)
            else:
              temp_values.append(temp_dict[i]+lamb)
          word=choices(vocab_list,temp_values)[0]
          if word != '</s>':
            s+=word+' '
            key=key[1:]+(word,)
            I=I+1
          elif word =='</s>' and I ==0:
            continue
          else:
            break
      print(s+' </s>')

    
def clean(data):
  data_list=[]
  for i in range(len(data)):
    l=[]
    sents=data[i] 
    for j in sents:
      s=''
      if len(re.findall(r'\D+-\D+',j)) >0:
        l+=re.split(r'-',j)
      else:
        for k in j:
          if k in string.punctuation:
            continue
          elif k.isdigit() == True:
            continue
          else:
            s+=k
        if s!='':
          l.append(s)
    if l!=[]:
      data_list.append(l) 
  return(data_list) 


def lower(data):
  data_list=[]
  for i in range(len(data)):
    l=[]
    sents=data[i]
    for j in sents:
      j=j.lower().strip()
      l.append(j)
    data_list.append(l)
  return(data_list)
